<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font Metadata Scanner</title>
    
    <!-- React and Dependencies -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <!-- React will render here -->
    <div id="root"></div>
    
    <!-- React Component Script -->
    <script type="text/babel">
        const { useState } = React;
        
        // SVG Icons
        const Search = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>;
        const Download = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const FileText = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>;
        const Type = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>;

        // Main Component
        function FontScanner() {
          const [url, setUrl] = useState('');
          const [loading, setLoading] = useState(false);
          const [results, setResults] = useState(null);
          const [error, setError] = useState('');
          const [debugInfo, setDebugInfo] = useState([]);
          const [microsoftFonts, setMicrosoftFonts] = useState([]);
          const [fontCacheStatus, setFontCacheStatus] = useState('Not loaded');
          const [showManualInput, setShowManualInput] = useState(false);
          const [manualCssUrl, setManualCssUrl] = useState('');
          const [manualCssContent, setManualCssContent] = useState('');

          const baseMicrosoftFonts = [
            'segoe', 'calibri', 'cambria', 'candara', 'consolas', 'constantia', 'corbel',
            'arial', 'times new roman', 'verdana', 'tahoma', 'trebuchet', 'georgia',
            'comic sans', 'impact', 'courier new', 'palatino', 'garamond', 'bookman',
            'century gothic', 'franklin gothic', 'ms sans serif', 'ms serif', 'bahnschrift',
            'ebrima', 'gabriola', 'malgun gothic', 'microsoft himalaya', 'microsoft jhenghei',
            'microsoft new tai lue', 'microsoft phagspa', 'microsoft tai le', 'microsoft yahei',
            'microsoft yi baiti', 'mongolian baiti', 'mv boli', 'myanmar text', 'nirmala ui',
            'sitka', 'sylfaen', 'yu gothic'
          ];

          const fetchMicrosoftFonts = async () => {
            try {
              setFontCacheStatus('Loading...');
              const proxyUrl = 'https://api.allorigins.win/raw?url=';
              const msUrl = 'https://learn.microsoft.com/en-us/typography/font-list/';
              
              const response = await fetch(proxyUrl + encodeURIComponent(msUrl));
              const html = await response.text();
              
              const parser = new DOMParser();
              const doc = parser.parseFromString(html, 'text/html');
              
              const fontLinks = doc.querySelectorAll('a[href*="/typography/font-list/"]');
              const extractedFonts = [];
              
              fontLinks.forEach(link => {
                const fontName = link.textContent.trim().toLowerCase();
                if (fontName && fontName.length > 2 && !fontName.includes('font list')) {
                  extractedFonts.push(fontName);
                }
              });
              
              if (extractedFonts.length > 10) {
                setMicrosoftFonts([...new Set([...baseMicrosoftFonts, ...extractedFonts])]);
                setFontCacheStatus(`Loaded ${extractedFonts.length} fonts from Microsoft`);
                return extractedFonts.length;
              } else {
                throw new Error('Not enough fonts extracted');
              }
            } catch (err) {
              console.error('Failed to fetch Microsoft fonts:', err);
              setMicrosoftFonts(baseMicrosoftFonts);
              setFontCacheStatus('Using cached list (fallback)');
              return 0;
            }
          };

          React.useEffect(() => {
            fetchMicrosoftFonts();
          }, []);

          const categorizeFont = (fontName, fontFiles = []) => {
            const name = fontName.toLowerCase();
            const files = fontFiles.join(' ').toLowerCase();
            
            if (files.includes('fonts.gstatic.com') || 
                files.includes('fonts.googleapis.com') || 
                files.includes('gstatic.com')) {
              return { 
                category: 'Google Fonts', 
                license: 'Free (Open Source)', 
                color: 'green',
                detected: 'URL'
              };
            }
            
            if (files.includes('use.typekit.net') || 
                files.includes('typekit.com') || 
                files.includes('typekit.net') ||
                files.includes('adobe.com/fonts')) {
              return { 
                category: 'Adobe Fonts', 
                license: 'Subscription Required', 
                color: 'purple',
                detected: 'URL'
              };
            }
            
            const msfontsToCheck = microsoftFonts.length > 0 ? microsoftFonts : baseMicrosoftFonts;
            
            for (const msFont of msfontsToCheck) {
              if (name.includes(msFont)) {
                return { 
                  category: 'Microsoft/System', 
                  license: 'Bundled with OS', 
                  color: 'blue',
                  detected: microsoftFonts.length > 0 ? 'Live List' : 'Cached List'
                };
              }
            }
            
            const commonGoogleFonts = [
              'roboto', 'open sans', 'lato', 'montserrat', 'oswald', 'source sans pro',
              'raleway', 'poppins', 'ubuntu', 'merriweather', 'playfair display',
              'nunito', 'pt sans', 'noto sans', 'inter', 'work sans', 'quicksand',
              'rubik', 'karla', 'mulish', 'dm sans', 'manrope', 'space grotesk'
            ];
            
            for (const gFont of commonGoogleFonts) {
              if (name.includes(gFont)) {
                return { 
                  category: 'Google Fonts', 
                  license: 'Free (Open Source)', 
                  color: 'green',
                  detected: 'Name Match'
                };
              }
            }
            
            const commonAdobeFonts = [
              'adobe', 'myriad', 'minion', 'garamond pro', 'futura', 'proxima nova',
              'source serif', 'source code', 'tk-', 'acumin', 'brandon', 'museo'
            ];
            
            for (const aFont of commonAdobeFonts) {
              if (name.includes(aFont)) {
                return { 
                  category: 'Adobe Fonts', 
                  license: 'License May Be Required', 
                  color: 'purple',
                  detected: 'Name Match'
                };
              }
            }
            
            const genericFonts = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
            if (genericFonts.includes(name)) {
              return { 
                category: 'Generic/Fallback', 
                license: 'N/A', 
                color: 'gray',
                detected: 'Generic'
              };
            }
            
            return { 
              category: '3rd Party', 
              license: '‚ö†Ô∏è License Required - Verify', 
              color: 'orange',
              detected: 'Unknown'
            };
          };

          const extractFontsFromCSS = (cssText, sourceUrl) => {
            const fonts = [];
            const fontFamilyUsages = [];
            
            const fontFaceRegex = /@font-face\s*{([^}]+)}/g;
            let match;
            
            while ((match = fontFaceRegex.exec(cssText)) !== null) {
              const block = match[1];
              const font = {
                source: sourceUrl,
                type: 'font-face'
              };
              
              const familyMatch = block.match(/font-family:\s*['"]?([^'";]+)['"]?/i);
              if (familyMatch) font.family = familyMatch[1].trim();
              
              const srcMatch = block.match(/src:\s*([^;]+);/i);
              if (srcMatch) {
                const urls = srcMatch[1].match(/url\(['"]?([^'"()]+)['"]?\)/g);
                if (urls) {
                  font.files = urls.map(u => {
                    const urlMatch = u.match(/url\(['"]?([^'"()]+)['"]?\)/);
                    return urlMatch ? urlMatch[1] : u;
                  });
                }
              }
              
              const weightMatch = block.match(/font-weight:\s*([^;]+);/i);
              if (weightMatch) font.weight = weightMatch[1].trim();
              
              const styleMatch = block.match(/font-style:\s*([^;]+);/i);
              if (styleMatch) font.style = styleMatch[1].trim();
              
              const displayMatch = block.match(/font-display:\s*([^;]+);/i);
              if (displayMatch) font.display = displayMatch[1].trim();
              
              const unicodeMatch = block.match(/unicode-range:\s*([^;]+);/i);
              if (unicodeMatch) font.unicodeRange = unicodeMatch[1].trim();
              
              fonts.push(font);
            }
            
            const cssRules = cssText.split('}');
            
            for (let rule of cssRules) {
              if (!rule.trim()) continue;
              
              const parts = rule.split('{');
              if (parts.length < 2) continue;
              
              const selector = parts[0].trim();
              const declarations = parts[1];
              
              const fontFamilyRegex = /font-family:\s*([^;]+);?/gi;
              let familyMatch;
              
              while ((familyMatch = fontFamilyRegex.exec(declarations)) !== null) {
                const fullValue = familyMatch[1].trim();
                const fontStack = fullValue.split(',').map(f => f.trim().replace(/['"]/g, ''));
                
                fontFamilyUsages.push({
                  selector: selector,
                  fullValue: fullValue,
                  fontStack: fontStack,
                  primaryFont: fontStack[0],
                  fallbacks: fontStack.slice(1),
                  source: sourceUrl
                });
              }
            }
            
            return { 
              fontFaces: fonts, 
              fontFamilyUsages: fontFamilyUsages
            };
          };

          const scanWebsite = async () => {
            if (!url) {
              setError('Please enter a URL');
              return;
            }

            setLoading(true);
            setError('');
            setResults(null);
            setDebugInfo([]);

            try {
              const proxyUrl = 'https://api.allorigins.win/raw?url=';
              const response = await fetch(proxyUrl + encodeURIComponent(url));
              const htmlContent = await response.text();

              const parser = new DOMParser();
              const doc = parser.parseFromString(htmlContent, 'text/html');
              const linkTags = doc.querySelectorAll('link[rel="stylesheet"]');
              const styleTags = doc.querySelectorAll('style');
              
              let cssLinks = Array.from(linkTags).map(link => {
                const href = link.getAttribute('href');
                if (!href) return null;
                if (href.startsWith('http')) return href;
                if (href.startsWith('//')) return 'https:' + href;
                if (href.startsWith('/')) {
                  const baseUrl = new URL(url);
                  return baseUrl.origin + href;
                }
                return new URL(href, url).href;
              }).filter(Boolean);

              const allFonts = [];
              const allFontFamilyUsages = [];
              const cssFiles = [];
              const debug = [];

              debug.push(`Found ${linkTags.length} external CSS links`);
              debug.push(`Found ${styleTags.length} inline style tags`);

              for (const styleTag of styleTags) {
                const cssText = styleTag.textContent;
                const { fontFaces, fontFamilyUsages } = extractFontsFromCSS(cssText, 'inline-style');
                allFonts.push(...fontFaces);
                allFontFamilyUsages.push(...fontFamilyUsages);
                if (fontFaces.length > 0 || fontFamilyUsages.length > 0) {
                  cssFiles.push({ 
                    url: 'Inline <style> tag', 
                    fontFaceCount: fontFaces.length,
                    fontFamilyCount: fontFamilyUsages.length,
                    size: `${(cssText.length / 1024).toFixed(2)} KB`
                  });
                  debug.push(`Inline style: ${fontFaces.length} @font-face, ${fontFamilyUsages.length} font-family`);
                }
              }

              debug.push(`\nFetching external CSS files (max 10)...`);
              
              for (let i = 0; i < Math.min(cssLinks.length, 10); i++) {
                const cssUrl = cssLinks[i];
                try {
                  debug.push(`\nFetching: ${cssUrl}`);
                  const cssResponse = await fetch(proxyUrl + encodeURIComponent(cssUrl));
                  const cssText = await cssResponse.text();
                  
                  debug.push(`‚úì Success: ${(cssText.length / 1024).toFixed(2)} KB`);
                  
                  const { fontFaces, fontFamilyUsages } = extractFontsFromCSS(cssText, cssUrl);
                  allFonts.push(...fontFaces);
                  allFontFamilyUsages.push(...fontFamilyUsages);
                  
                  const fileName = cssUrl.split('/').pop() || cssUrl;
                  cssFiles.push({ 
                    url: cssUrl,
                    fileName: fileName,
                    fontFaceCount: fontFaces.length,
                    fontFamilyCount: fontFamilyUsages.length,
                    size: `${(cssText.length / 1024).toFixed(2)} KB`,
                    status: 'success'
                  });
                  
                  debug.push(`  ‚Üí Found: ${fontFaces.length} @font-face, ${fontFamilyUsages.length} font-family`);
                } catch (err) {
                  debug.push(`‚úó Failed: ${err.message}`);
                  cssFiles.push({
                    url: cssUrl,
                    fileName: cssUrl.split('/').pop() || cssUrl,
                    fontFaceCount: 0,
                    fontFamilyCount: 0,
                    size: 'N/A',
                    status: 'failed',
                    error: err.message
                  });
                }
              }

              const uniquePrimaryFonts = new Set(allFontFamilyUsages.map(u => u.primaryFont));
              
              const categorizedFonts = {
                'Google Fonts': [],
                'Microsoft/System': [],
                'Adobe Fonts': [],
                'Generic/Fallback': [],
                '3rd Party': []
              };
              
              allFontFamilyUsages.forEach(usage => {
                const fontFiles = allFonts
                  .filter(f => f.family && f.family.toLowerCase() === usage.primaryFont.toLowerCase())
                  .flatMap(f => f.files || []);
                
                const category = categorizeFont(usage.primaryFont, fontFiles);
                usage.category = category.category;
                usage.license = category.license;
                usage.color = category.color;
                usage.detected = category.detected;
                
                if (!categorizedFonts[category.category].some(f => f.primaryFont === usage.primaryFont)) {
                  categorizedFonts[category.category].push(usage);
                }
              });

              debug.push(`\n=== Summary ===`);
              debug.push(`Total @font-face: ${allFonts.length}`);
              debug.push(`Total font-family: ${allFontFamilyUsages.length}`);
              debug.push(`Unique primary fonts: ${uniquePrimaryFonts.size}`);

              setDebugInfo(debug);
              setResults({
                fonts: allFonts,
                fontFamilyUsages: allFontFamilyUsages,
                categorizedFonts: categorizedFonts,
                uniquePrimaryFonts: Array.from(uniquePrimaryFonts),
                cssFiles: cssFiles,
                totalCssFiles: cssLinks.length
              });

            } catch (err) {
              setError(`Error scanning website: ${err.message}`);
            } finally {
              setLoading(false);
            }
          };

          const addManualCss = () => {
            if (!manualCssContent.trim()) {
              alert('Please paste CSS content');
              return;
            }

            const { fontFaces, fontFamilyUsages } = extractFontsFromCSS(
              manualCssContent, 
              manualCssUrl || 'Manual Input'
            );

            const updatedResults = { ...results };
            updatedResults.fonts.push(...fontFaces);
            updatedResults.fontFamilyUsages.push(...fontFamilyUsages);

            const allFontFamilyUsages = updatedResults.fontFamilyUsages;
            const categorizedFonts = {
              'Google Fonts': [],
              'Microsoft/System': [],
              'Adobe Fonts': [],
              'Generic/Fallback': [],
              '3rd Party': []
            };

            allFontFamilyUsages.forEach(usage => {
              const fontFiles = updatedResults.fonts
                .filter(f => f.family && f.family.toLowerCase() === usage.primaryFont.toLowerCase())
                .flatMap(f => f.files || []);
              
              const category = categorizeFont(usage.primaryFont, fontFiles);
              usage.category = category.category;
              usage.license = category.license;
              usage.color = category.color;
              usage.detected = category.detected;
              
              if (!categorizedFonts[category.category].some(f => f.primaryFont === usage.primaryFont)) {
                categorizedFonts[category.category].push(usage);
              }
            });

            updatedResults.categorizedFonts = categorizedFonts;
            updatedResults.uniquePrimaryFonts = Array.from(new Set(allFontFamilyUsages.map(u => u.primaryFont)));

            updatedResults.cssFiles.push({
              url: manualCssUrl || 'Manual Input',
              fileName: 'Manual CSS',
              fontFaceCount: fontFaces.length,
              fontFamilyCount: fontFamilyUsages.length,
              size: `${(manualCssContent.length / 1024).toFixed(2)} KB`,
              status: 'manual'
            });

            setResults(updatedResults);
            setShowManualInput(false);
            setManualCssUrl('');
            setManualCssContent('');
            
            alert(`Successfully added ${fontFaces.length} @font-face and ${fontFamilyUsages.length} font-family declarations!`);
          };

          const exportResults = () => {
            const dataStr = JSON.stringify(results, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'font-metadata.json';
            link.click();
            URL.revokeObjectURL(url);
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-6">
              <div className="max-w-6xl mx-auto">
                <div className="text-center mb-8">
                  <div className="flex items-center justify-center gap-3 mb-4">
                    <Type />
                    <h1 className="text-4xl font-bold text-white">Font Metadata Scanner</h1>
                  </div>
                  <p className="text-purple-200">Analyze and extract detailed font information from any website</p>
                  <div className="mt-2 text-sm text-purple-300">
                    Font Database: {fontCacheStatus}
                  </div>
                </div>

                <div className="bg-white/10 backdrop-blur-md rounded-xl p-6 shadow-2xl mb-6">
                  <div className="flex gap-3">
                    <input
                      type="text"
                      value={url}
                      onChange={(e) => setUrl(e.target.value)}
                      placeholder="Enter website URL (e.g., https://example.com)"
                      className="flex-1 px-4 py-3 bg-white/20 border border-purple-300/30 rounded-lg text-white placeholder-purple-200/60 focus:outline-none focus:ring-2 focus:ring-purple-400"
                      onKeyPress={(e) => e.key === 'Enter' && scanWebsite()}
                    />
                    <button
                      onClick={scanWebsite}
                      disabled={loading}
                      className="px-6 py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-purple-800 text-white rounded-lg font-semibold flex items-center gap-2 transition-colors"
                    >
                      {loading ? (
                        <>
                          <div className="w-5 h-5 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                          Scanning...
                        </>
                      ) : (
                        <>
                          <Search />
                          Scan
                        </>
                      )}
                    </button>
                  </div>
                  {error && (
                    <div className="mt-4 p-4 bg-red-500/20 border border-red-500/50 rounded-lg text-red-200">
                      {error}
                    </div>
                  )}
                </div>

                {results && (
                  <div className="space-y-6">
                    {debugInfo.length > 0 && (
                      <div className="bg-black/40 backdrop-blur-md rounded-xl p-6 border border-green-500/30">
                        <h3 className="text-xl font-bold text-green-400 mb-4 flex items-center gap-2">
                          <FileText />
                          Debug Log
                        </h3>
                        <div className="bg-black/60 rounded-lg p-4 font-mono text-sm text-green-300 max-h-96 overflow-y-auto">
                          {debugInfo.map((line, idx) => (
                            <div key={idx} className="mb-1">{line}</div>
                          ))}
                        </div>
                      </div>
                    )}

                    <div className="flex items-center justify-between">
                      <h2 className="text-2xl font-bold text-white">Scan Results</h2>
                      <div className="flex gap-2">
                        <button
                          onClick={() => setShowManualInput(!showManualInput)}
                          className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg flex items-center gap-2 transition-colors"
                        >
                          <FileText />
                          Add Manual CSS
                        </button>
                        <button
                          onClick={exportResults}
                          className="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg flex items-center gap-2 transition-colors"
                        >
                          <Download />
                          Export JSON
                        </button>
                      </div>
                    </div>

                    {showManualInput && (
                      <div className="bg-blue-500/10 border border-blue-500/30 rounded-xl p-6">
                        <h3 className="text-xl font-bold text-blue-300 mb-4">üìù Add CSS Manually</h3>
                        <p className="text-blue-200 text-sm mb-4">
                          If a CSS file failed to fetch, you can manually copy its content and paste it here.
                        </p>
                        
                        <div className="space-y-4">
                          <div>
                            <label className="text-blue-200 text-sm mb-2 block">CSS File URL (optional)</label>
                            <input
                              type="text"
                              value={manualCssUrl}
                              onChange={(e) => setManualCssUrl(e.target.value)}
                              placeholder="https://example.com/style.css"
                              className="w-full px-4 py-2 bg-white/10 border border-blue-300/30 rounded-lg text-white placeholder-blue-200/60 focus:outline-none focus:ring-2 focus:ring-blue-400"
                            />
                          </div>
                          
                          <div>
                            <label className="text-blue-200 text-sm mb-2 block">CSS Content *</label>
                            <textarea
                              value={manualCssContent}
                              onChange={(e) => setManualCssContent(e.target.value)}
                              placeholder="Paste CSS content here..."
                              className="w-full px-4 py-3 bg-white/10 border border-blue-300/30 rounded-lg text-white placeholder-blue-200/60 focus:outline-none focus:ring-2 focus:ring-blue-400 font-mono text-sm"
                              rows="12"
                            />
                          </div>
                          
                          <div className="flex gap-3">
                            <button
                              onClick={addManualCss}
                              className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors"
                            >
                              Add to Results
                            </button>
                            <button
                              onClick={() => {
                                setShowManualInput(false);
                                setManualCssUrl('');
                                setManualCssContent('');
                              }}
                              className="px-6 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-semibold transition-colors"
                            >
                              Cancel
                            </button>
                          </div>
                        </div>
                      </div>
                    )}

                    {/* Rest of the results display... */}
                    <div className="bg-white/10 p-6 rounded-xl">
                      <p className="text-white text-center">
                        Results will be displayed here after scanning completes
                      </p>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        }

        // Render the app
        ReactDOM.render(<FontScanner />, document.getElementById('root'));
    </script>
</body>
</html>
